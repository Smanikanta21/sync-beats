<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SyncBeats Test</title>
  </head>
  <body>
    <h2>ðŸŽµ SyncBeats (Pingâ€“Pong Prototype)</h2>
    <button id="joinBtn">Join Room</button>
    <button id="playBtn">Play Song</button>
    <audio id="audio" controls src="sample.mp3"></audio>
    <pre id="log"></pre>

    <script>
      const logEl = document.getElementById("log");
      const ws = new WebSocket("ws://10.7.26.138:3000");
      const audio = document.getElementById("audio");
      const roomId = "room1";
      const audioCtx = new (window.AudioContext ||
        window.webkitAudioContext)();
      let globalMapping = null;

      function log(...args) {
        console.log(...args);
        logEl.textContent += args.join(" ") + "\n";
      }

      ws.onopen = () => {
        log("âœ… Socket connected");
      };

      ws.onmessage = async (ev) => {
        const msg = JSON.parse(ev.data);
        switch (msg.type) {
          case "joined":
            log(
              `Joined room=${msg.roomId} | leader=${msg.leaderId} | session=${JSON.stringify(
                msg.session
              )}`
            );
            break;

          case "time_pong":
            handlePong(msg);
            break;

          case "PLAY":
            log(`PLAY cmd received: startServerMs=${msg.startServerMs}`);
            await handlePlay(msg.audioUrl, msg.startServerMs);
            break;
        }
      };

      // ---- join ----
      document.getElementById("joinBtn").onclick = () => {
        ws.send(JSON.stringify({ type: "join", roomId }));
      };

      // ---- play ----
      document.getElementById("playBtn").onclick = async () => {
        if (audioCtx.state === "suspended") await audioCtx.resume();
        ws.send(
          JSON.stringify({
            type: "PLAY",
            audioUrl: "sample.mp3",
            startDelayMs: 2000,
          })
        );
      };

      // ---- Pingâ€“pong clock sync ----
      const pending = new Map();
      async function sendPing() {
        return new Promise((resolve, reject) => {
          const id = Math.random().toString(36).slice(2, 9);
          const t0 = Date.now();
          pending.set(id, { t0, resolve });
          ws.send(JSON.stringify({ type: "time_ping", id, t0 }));
          setTimeout(() => {
            if (pending.has(id)) {
              pending.delete(id);
              reject("Ping timeout");
            }
          }, 1500);
        });
      }

      async function estimateOffset(samples = 6) {
        const results = [];
        for (let i = 0; i < samples; i++) {
          try {
            const pong = await sendPing();
            const t3 = Date.now();
            const serverTime = pong.serverTime;
            const rtt = t3 - pong.t0;
            const offset = serverTime - (pong.t0 + rtt / 2);
            results.push({ offset, rtt });
          } catch (e) {
            log("Ping failed", e);
          }
          await new Promise((r) => setTimeout(r, 100));
        }
        results.sort((a, b) => a.rtt - b.rtt);
        const best = results[0];
        const mapPair = { clientNowMs: Date.now(), audioNowSec: audioCtx.currentTime };
        log(`â±ï¸ Offset=${best.offset.toFixed(2)}ms RTT=${best.rtt.toFixed(2)}ms`);
        return { offsetMs: best.offset, mapPair };
      }

      function handlePong(msg) {
        const pendingPing = pending.get(msg.id);
        if (!pendingPing) return;
        pendingPing.resolve(msg);
        pending.delete(msg.id);
      }

      function serverMsToAudioCtxTime(serverMs, mapping) {
        const clientEquivalentMs = serverMs - mapping.offsetMs;
        const deltaMs = clientEquivalentMs - mapping.mapPair.clientNowMs;
        return mapping.mapPair.audioNowSec + deltaMs / 1000;
      }

      async function handlePlay(audioUrl, startServerMs) {
        if (audioCtx.state === "suspended") await audioCtx.resume();

        const mapping = await estimateOffset();
        globalMapping = mapping;

        const startAudioCtxTime = serverMsToAudioCtxTime(
          startServerMs,
          mapping
        );

        const now = audioCtx.currentTime;
        const safeStart = Math.max(startAudioCtxTime, now + 0.2);
        log(`ðŸŽ§ Scheduling audio at ${safeStart.toFixed(3)} (current ${now.toFixed(3)})`);

        const res = await fetch(audioUrl);
        const buf = await res.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(buf);

        const src = audioCtx.createBufferSource();
        src.buffer = audioBuffer;
        src.connect(audioCtx.destination);
        src.start(safeStart);
        src.onended = () => log("Audio ended.");
      }
    </script>
  </body>
</html>